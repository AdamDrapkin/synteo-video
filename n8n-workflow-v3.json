{
  "name": "Content Rewards - Full Pipeline v3",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "content-rewards-trigger",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "trigger-webhook",
      "name": "1. Webhook Trigger",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [0, 300],
      "webhookId": "content-rewards"
    },
    {
      "parameters": {
        "jsCode": "// Parse webhook input\nconst input = $input.first().json;\n\n// Extract campaign info\nconst campaignName = input.campaign_name || input.campaign;\nconst youtubeUrl = input.youtube_url || input.youtubeUrl;\nconst adamNotes = input.adam_notes || input.notes || \"\";\nconst episodeTitle = input.episode_title || input.episodeTitle || \"\";\nconst episodeNumber = input.episode_number || input.episodeNumber || \"\";\nconst accountToPost = input.account_to_post_from || input.accountToPost || \"\";\n\nif (!youtubeUrl) {\n  throw new Error(\"youtube_url is required\");\n}\n\nif (!campaignName) {\n  throw new Error(\"campaign_name is required\");\n}\n\nreturn [{\n  json: {\n    campaign_name: campaignName,\n    youtube_url: youtubeUrl,\n    adam_notes: adamNotes,\n    episode_title: episodeTitle,\n    episode_number: episodeNumber,\n    account_to_post_from: accountToPost,\n    status: \"started\",\n    started_at: new Date().toISOString()\n  }\n}];",
        "outputs": ["main"]
      },
      "id": "parse-input",
      "name": "2. Parse Webhook Input",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [220, 300]
    },
    {
      "parameters": {
        "operation": "get",
        "base": {
          "__rl": true,
          "value": "{{$env.AIRTABLE_APP_ID}}",
          "mode": "id"
        },
        "table": {
          "__rl": true,
          "value": "tblCAMPAIGNS",
          "mode": "id"
        },
        "filters": {
          "filterByFormula": "={name}='{{ $json.campaign_name }}'",
          "maxRecords": 1
        },
        "options": {}
      },
      "id": "lookup-campaign",
      "name": "3. Lookup Campaign Config",
      "type": "n8n-nodes-base.airtable",
      "typeVersion": 3,
      "position": [440, 300],
      "credentials": {
        "airtableTokenApi": {
          "id": "[REPLACE: Airtable Token]",
          "name": "Airtable Personal Access Token"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Build campaign config from Airtable response\nconst campaignRecord = $input.first().json;\nconst fields = campaignRecord.fields || {};\n\nconst config = {\n  platform: fields.platform || \"tiktok\",\n  music_category: fields.music_category || \"upbeat\",\n  caption_style: fields.caption_style || \"conversational\",\n  required_hashtags: fields.required_hashtags || \"\",\n  required_mentions: fields.required_mentions || \"\",\n  clip_length_min: fields.clip_length_min || 30,\n  clip_length_max: fields.clip_length_max || 90,\n  hook_style: fields.hook_style || \"controversy\",\n  tier1_requirement: fields.tier1_requirement || \"\",\n  caption_instructions: fields.caption_instructions || \"\"\n};\n\nconst input = $input.first().json;\nreturn [{\n  json: {\n    ...input,\n    campaign_config: config\n  }\n}];",
        "outputs": ["main"]
      },
      "id": "build-campaign-config",
      "name": "4. Build Campaign Config",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [660, 300]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{$env.API_BASE_URL}}/media/download",
        "bodyParameters": {
          "parameters": [
            {
              "name": "youtube_url",
              "value": "={{ $json.youtube_url }}"
            }
          ]
        },
        "options": {
          "timeout": 300000,
          "retry": {
            "enabled": true,
            "maxTries": 3,
            "waitBetweenTries": 5000
          }
        }
      },
      "id": "download-video",
      "name": "5. Download YouTube Video",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [880, 300]
    },
    {
      "parameters": {
        "jsCode": "// Build Prompt 1 - Viral Clip Identifier\nconst input = $input.first().json;\nconst transcript = input.transcript || \"\";\nconst config = input.campaign_config || {};\nconst notes = input.adam_notes || \"\";\n\nconst prompt1 = `You are an elite short-form video strategist. Your job is to identify the most viral moments from a transcript.\n\nTRANSCRIPT:\n${transcript}\n\nCAMPAIGN CONTEXT:\n- Platform: ${config.platform}\n- Hook Style: ${config.hook_style}\n- Min Clip Length: ${config.clip_length_min}s\n- Max Clip Length: ${config.clip_length_max}s\n\nADAM'S NOTES:\n${notes}\n\nTASK:\nAnalyze the transcript and identify 5-10 viral clip segments. Each clip needs:\n1. hook_timestamp_start - 3-second pattern interrupt (from earlier in video)\n2. hook_timestamp_end - always hook_start + 3 seconds\n3. main_timestamp_start - where actual clip begins\n4. main_timestamp_end - where clip ends\n5. hook_score (1-10)\n6. trigger_type: Controversy/Confession/Revelation/Question/Emotional\n7. opening_line - first 5-10 words spoken\n8. why_it_hits - why this will perform well\n9. retention_arc - hook/tension/payoff timestamps\n10. risk_flags - any potential issues\n\nReturn a JSON array of clips ranked by virality potential.`;\n\n\nreturn [{\n  json: {\n    ...input,\n    prompt_1: prompt1\n  }\n}];",
        "outputs": ["main"]
      },
      "id": "build-prompt1",
      "name": "6. Build Prompt 1",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1100, 300]
    },
    {
      "parameters": {
        "operation": "chat",
        "model": "claude-sonnet-4-20250514",
        "messages": {
          "messages": [
            {
              "role": "user",
              "content": "={{ $json.prompt_1 }}"
            }
          ]
        },
        "options": {
          "timeout": 120
        }
      },
      "id": "claude-prompt1",
      "name": "7. Claude - Identify Viral Clips",
      "type": "n8n-nodes-base.anthropic",
      "typeVersion": 1,
      "position": [1320, 300],
      "credentials": {
        "anthropicApi": {
          "id": "[REPLACE: Anthropic API Key]",
          "name": "Anthropic API Key"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Parse Claude Prompt 1 response\nconst response = $input.first().json;\nconst content = response.message?.content || response.text || \"\";\n\n// Extract JSON from response\nconst jsonMatch = content.match(/\\[[\\s\\S]*\\]/);\nlet clips = [];\n\nif (jsonMatch) {\n  try {\n    clips = JSON.parse(jsonMatch[0]);\n  } catch (e) {\n    clips = [];\n  }\n}\n\nif (!clips.length) {\n  throw new Error(\"No clips returned from Claude\");\n}\n\n// Format for Slack\nconst formattedClips = clips.map((clip, i) => {\n  return `*Clip ${i + 1}* (Score: ${clip.hook_score}/10)\\n` +\n    `üìù \"${clip.opening_line}\"\\n` +\n    `üéØ ${clip.trigger_type} | ${clip.why_it_hits}\\n` +\n    `‚è±Ô∏è ${clip.main_timestamp_start}s - ${clip.main_timestamp_end}s`;\n}).join(\"\\n\\n\");\n\nreturn [{\n  json: {\n    ...$input.first().json,\n    clips,\n    formattedClips,\n    clip_count: clips.length\n  }\n}];",
        "outputs": ["main"]
      },
      "id": "parse-clips",
      "name": "8. Parse Viral Clips",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1540, 300]
    },
    {
      "parameters": {
        "channel": "={{ $json.campaign_name }}",
        "text": "=üé¨ *Clip Selection Required*\\n\\nüì∫ *{{$json.episode_title}}*\\nCampaign: *{{$json.campaign_name}}*\\n\\n{{$json.formattedClips}}\\n\\n_Reply with clip numbers to produce (e.g., \"1, 3\")_",
        "additionalFields": {}
      },
      "id": "slack-clips",
      "name": "9. Slack - Select Clips",
      "type": "n8n-nodes-base.slack",
      "typeVersion": 3,
      "position": [1760, 300],
      "credentials": {
        "slackApi": {
          "id": "[REPLACE: Slack Bot Token]",
          "name": "Slack Bot Token"
        }
      }
    },
    {
      "parameters": {
        "amount": 30,
        "unit": "minutes"
      },
      "id": "wait-clips",
      "name": "9. Wait for Clip Selection",
      "type": "n8n-nodes-base.wait",
      "typeVersion": 1.1,
      "position": [1980, 300]
    },
    {
      "parameters": {
        "jsCode": "// Parse Adam's clip selection\nconst reply = $input.first().json.text || \"\";\nconst allClips = $input.first().json.clips || [];\n\n// Extract numbers (e.g., \"1, 3\" -> [0, 2])\nconst selectedNums = reply\n  .split(/[,;\\s]+/)\n  .map(n => parseInt(n.trim()) - 1)\n  .filter(n => !isNaN(n) && n >= 0 && n < allClips.length);\n\n\nif (!selectedNums.length) {\n  throw new Error(\"No valid clips selected\");\n}\n\nconst selectedClips = selectedNums.map(i => allClips[i]);\n\nreturn [{\n  json: {\n    ...$input.first().json,\n    selected_clips: selectedClips,\n    clip_count: selectedClips.length\n  }\n}];",
        "outputs": ["main"]
      },
      "id": "parse-selection",
      "name": "10. Parse Clip Selection",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2200, 300]
    },
    {
      "parameters": {
        "batchSize": 1
      },
      "id": "loop-clips",
      "name": "11. Loop Over Clips",
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [2420, 300]
    },
    {
      "parameters": {
        "jsCode": "// Build Prompt 2 - Caption Generator\nconst clip = $input.first().json;\nconst config = $input.first().json.campaign_config || {};\nconst allInput = $input.first().json;\n\nconst prompt2 = `You are an elite short-form caption strategist. Generate captions for this clip.\n\nCLIP INFO:\n- Opening: ${clip.opening_line}\n- Trigger: ${clip.trigger_type}\n- Why: ${clip.why_it_hits}\n\nPLATFORM: ${config.platform}\nCAMPAIGN RULES:\n- Hashtags: ${config.required_hashtags}\n- Mentions: ${config.required_mentions}\n- Style: ${config.caption_style}\n\nADAM'S NOTES: ${allInput.adam_notes || \"None\"}\n\nTASK:\nGenerate 3 caption variants:\n- Variant A: Curiosity Gap (for TikTok algorithm)\n- Variant B: Stakes/Emotional (for Instagram saves)\n- Variant C: Direct Keyword (for YouTube Shorts)\n\nPlus 5 hook overlay variations:\n- TEXT CLAIM: Bold statement/number on screen\n- PROOF SIGNAL: Reference to visible evidence\n- CONTRADICTION: Opposes common belief\n- EMOTION TRIGGER: Lead with feeling\n- SOCIAL PROOF: Lead with others' results\n\nFor each caption: <150 chars, include hashtags, campaign tag.\n\nReturn JSON with:\n{\n  \"captions\": [variant_a, variant_b, variant_c],\n  \"hook_overlays\": [overlay_1, overlay_2, overlay_3, overlay_4, overlay_5],\n  \"recommended\": { \"platform\": \"tiktok\", \"caption\": \"A\", \"overlay\": \"1\" }\n}`;\n\n\nreturn [{\n  json: {\n    ...clip,\n    prompt_2: prompt2\n  }\n}];",
        "outputs": ["main"]
      },
      "id": "build-prompt2",
      "name": "12. Build Prompt 2",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2640, 300]
    },
    {
      "parameters": {
        "operation": "chat",
        "model": "claude-3-haiku-20240307",
        "messages": {
          "messages": [
            {
              "role": "user",
              "content": "={{ $json.prompt_2 }}"
            }
          ]
        },
        "options": {
          "timeout": 60
        }
      },
      "id": "claude-prompt2",
      "name": "13. Claude - Generate Captions",
      "type": "n8n-nodes-base.anthropic",
      "typeVersion": 1,
      "position": [2860, 300],
      "credentials": {
        "anthropicApi": {
          "id": "[REPLACE: Anthropic API Key]",
          "name": "Anthropic API Key"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Parse caption variants\nconst response = $input.first().json;\nconst content = response.message?.content || response.text || \"\";\n\nconst jsonMatch = content.match(/\\{[\\s\\S]*\\}/);\nlet data = {};\n\nif (jsonMatch) {\n  try {\n    data = JSON.parse(jsonMatch[0]);\n  } catch (e) {\n    data = {};\n  }\n}\n\nconst captions = data.captions || [];\nconst overlays = data.hook_overlays || [];\n\n// Format for Slack\nconst formattedVariants = captions.map((v, i) => {\n  const letter = [\"A\", \"B\", \"C\"][i];\n  return `*Variant ${letter}*: ${v.recommended ? \"‚≠ê\" : \"\"}\\n\"${v.caption}\"`;\n}).join(\"\\n\\n\");\n\nconst formattedOverlays = overlays.map((o, i) => {\n  return `${i + 1}. ${o.type}: \"${o.text}\"`;\n}).join(\"\\n\");\n\nreturn [{\n  json: {\n    ...response,\n    caption_variants: captions,\n    hook_overlays: overlays,\n    formattedVariants,\n    formattedOverlays,\n    recommended: data.recommended || {}\n  }\n}];",
        "outputs": ["main"]
      },
      "id": "parse-captions",
      "name": "14. Parse Captions",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [3080, 300]
    },
    {
      "parameters": {
        "channel": "={{ $json.campaign_name }}",
        "text": "=‚úçÔ∏è *Caption Selection*\\n\\nClip: {{$json.opening_line}}\\n\\n*VARIANTS:*\\n{{$json.formattedVariants}}\\n\\n*HOOK OVERLAYS:*\\n{{$json.formattedOverlays}}\\n\\n_Reply with variant (A/B/C) and overlay (1-5)_",
        "additionalFields": {}
      },
      "id": "slack-captions",
      "name": "15. Slack - Select Caption",
      "type": "n8n-nodes-base.slack",
      "typeVersion": 3,
      "position": [3300, 300],
      "credentials": {
        "slackApi": {
          "id": "[REPLACE: Slack Bot Token]",
          "name": "Slack Bot Token"
        }
      }
    },
    {
      "parameters": {
        "amount": 30,
        "unit": "minutes"
      },
      "id": "wait-captions",
      "name": "15. Wait for Caption",
      "type": "n8n-nodes-base.wait",
      "typeVersion": 1.1,
      "position": [3520, 300]
    },
    {
      "parameters": {
        "jsCode": "// Parse caption selection\nconst reply = ($input.first().json.text || \"\").toUpperCase();\nconst variants = $input.first().json.caption_variants || [];\nconst overlays = $input.first().json.hook_overlays || [];\n\n// Parse format: \"A3\" or \"A, 3\" or \"A and 3\"\nconst variantMatch = reply.match(/([ABC])/i);\nconst overlayMatch = reply.match(/(\\d)/);\n\nconst variantIdx = { A: 0, B: 1, C: 2 }[(variantMatch?.[1] || \"A\").toUpperCase()];\nconst overlayIdx = parseInt(overlayMatch?.[1] || \"1\") - 1;\n\nconst selectedCaption = variants[variantIdx] || variants[0];\nconst selectedOverlay = overlays[overlayIdx] || overlays[0];\n\nreturn [{\n  json: {\n    ...$input.first().json,\n    confirmed_caption: selectedCaption,\n    confirmed_overlay: selectedOverlay\n  }\n}];",
        "outputs": ["main"]
      },
      "id": "parse-caption-select",
      "name": "16. Parse Caption Selection",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [3740, 300]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{$env.API_BASE_URL}}/media/trim",
        "bodyParameters": {
          "parameters": [
            {
              "name": "inputUrl",
              "value": "={{ $json.video_url }}"
            },
            {
              "name": "startTime",
              "value": "={{ $json.hook_timestamp_start }}"
            },
            {
              "name": "endTime",
              "value": "={{ $json.hook_timestamp_end }}"
            }
          ]
        },
        "options": {
          "timeout": 300000,
          "retry": {
            "enabled": true,
            "maxTries": 3,
            "waitBetweenTries": 5000
          }
        }
      },
      "id": "trim-hook",
      "name": "17a. Trim Hook Clip",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [3960, 200]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{$env.API_BASE_URL}}/media/trim",
        "bodyParameters": {
          "parameters": [
            {
              "name": "inputUrl",
              "value": "={{ $json.video_url }}"
            },
            {
              "name": "startTime",
              "value": "={{ $json.main_timestamp_start }}"
            },
            {
              "name": "endTime",
              "value": "={{ $json.main_timestamp_end }}"
            }
          ]
        },
        "options": {
          "timeout": 300000,
          "retry": {
            "enabled": true,
            "maxTries": 3,
            "waitBetweenTries": 5000
          }
        }
      },
      "id": "trim-main",
      "name": "17b. Trim Main Clip",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [3960, 400]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{$env.API_BASE_URL}}/media/transcribe",
        "bodyParameters": {
          "parameters": [
            {
              "name": "audioUrl",
              "value": "={{ $json.mainClipUrl }}"
            }
          ]
        },
        "options": {
          "timeout": 180000,
          "retry": {
            "enabled": true,
            "maxTries": 3,
            "waitBetweenTries": 5000
          }
        }
      },
      "id": "transcribe",
      "name": "18. Transcribe Main Clip",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [4180, 300]
    },
    {
      "parameters": {
        "jsCode": "// Build SocialClipProps\nconst input = $input.first().json;\nconst caption = input.confirmed_caption || {};\nconst overlay = input.confirmed_overlay || {};\nconst captions = input.captions || [];\n\n// Offset captions by 3000ms for hook duration\nconst offsetCaptions = captions.map(c => ({\n  ...c,\n  startMs: c.startMs + 3000,\n  endMs: c.endMs + 3000\n}));\n\nconst props = {\n  hookClipUrl: input.hookClipUrl,\n  mainClipUrl: input.mainClipUrl,\n  captionData: offsetCaptions,\n  campaignTag: caption.campaign_tag || \"\",\n  hookOverlayText: overlay.text || caption.hook_overlay_text || \"\",\n  aspectRatio: \"9:16\"\n};\n\nreturn [{\n  json: {\n    ...input,\n    socialClipProps: props\n  }\n}];",
        "outputs": ["main"]
      },
      "id": "build-props",
      "name": "19. Build Render Props",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [4400, 300]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{$env.API_BASE_URL}}/render-with-webhook",
        "bodyParameters": {
          "parameters": [
            {
              "name": "composition",
              "value": "SocialClip"
            },
            {
              "name": "inputProps",
              "value": "={{ $json.socialClipProps }}"
            },
            {
              "name": "n8nResumeUrl",
              "value": "={{ $execution.resumeUrl }}"
            }
          ]
        },
        "options": {
          "timeout": 60000,
          "retry": {
            "enabled": true,
            "maxTries": 3,
            "waitBetweenTries": 5000
          }
        }
      },
      "id": "render-start",
      "name": "20. Start Lambda Render",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [4620, 300]
    },
    {
      "parameters": {
        "amount": 3,
        "unit": "minutes"
      },
      "id": "wait-render",
      "name": "20. Wait for Render",
      "type": "n8n-nodes-base.wait",
      "typeVersion": 1.1,
      "position": [4840, 300]
    },
    {
      "parameters": {
        "jsCode": "// Parse Lambda webhook payload\nconst data = $input.first().json;\n\nif (data.status === 'failed') {\n  throw new Error(`Render failed: ${data.error}`);\n}\n\nreturn [{\n  json: {\n    ...$input.first().json,\n    outputFile: data.outputFile,\n    renderId: data.renderId,\n    render_status: data.status\n  }\n}];",
        "outputs": ["main"]
      },
      "id": "parse-render",
      "name": "21. Parse Render Result",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [5060, 300]
    },
    {
      "parameters": {
        "channel": "={{ $json.campaign_name }}",
        "text": "=‚úÖ *Final Review Required*\\n\\nüé¨ {{$json.opening_line}}\\n\\nüìù Caption: \"{{$json.confirmed_caption.caption}}\"\\n\\nüîó {{$json.outputFile}}\\n\\n_Reply with APPROVE, REJECT, or NOTES_",
        "additionalFields": {}
      },
      "id": "slack-final",
      "name": "22. Slack - Final Review",
      "type": "n8n-nodes-base.slack",
      "typeVersion": 3,
      "position": [5280, 300],
      "credentials": {
        "slackApi": {
          "id": "[REPLACE: Slack Bot Token]",
          "name": "Slack Bot Token"
        }
      }
    },
    {
      "parameters": {
        "amount": 60,
        "unit": "minutes"
      },
      "id": "wait-final",
      "name": "22. Wait for Final",
      "type": "n8n-nodes-base.wait",
      "typeVersion": 1.1,
      "position": [5500, 300]
    },
    {
      "parameters": {
        "jsCode": "// Parse final decision\nconst reply = ($input.first().json.text || \"\").toUpperCase();\nconst approved = reply.includes(\"APPROVE\");\n\nreturn [{\n  json: {\n    ...$input.first().json,\n    approved,\n    decision: reply\n  }\n}];",
        "outputs": ["main"]
      },
      "id": "parse-final",
      "name": "23. Parse Final Decision",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [5720, 300]
    },
    {
      "parameters": {
        "operation": "create",
        "base": {
          "__rl": true,
          "value": "{{$env.AIRTABLE_APP_ID}}",
          "mode": "id"
        },
        "table": {
          "__rl": true,
          "value": "tblCLIPS",
          "mode": "id"
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "Campaign": "={{ $json.campaign_name }}",
            "Episode Title": "={{ $json.episode_title }}",
            "Episode Number": "={{ $json.episode_number }}",
            "Opening Line": "={{ $json.opening_line }}",
            "Caption": "={{ $json.confirmed_caption.caption }}",
            "Hook Overlay Text": "={{ $json.confirmed_overlay.text }}",
            "Hashtags": "={{ $json.confirmed_caption.hashtags }}",
            "Campaign Tag": "={{ $json.confirmed_caption.campaign_tag }}",
            "Account to Post From": "={{ $json.account_to_post_from }}",
            "Render ID": "={{ $json.renderId }}",
            "Output URL": "={{ $json.outputFile }}",
            "Status": "={{ $json.approved ? 'READY_TO_POST' : 'NEEDS_REVISION' }}"
          }
        },
        "options": {}
      },
      "id": "airtable-create",
      "name": "24. Airtable - Create Record",
      "type": "n8n-nodes-base.airtable",
      "typeVersion": 3,
      "position": [5940, 300],
      "credentials": {
        "airtableTokenApi": {
          "id": "[REPLACE: Airtable Token]",
          "name": "Airtable Personal Access Token"
        }
      }
    },
    {
      "parameters": {
        "channel": "content-rewards",
        "text": "=üéâ *Clip Ready!*\\n\\nCampaign: *{{$json.campaign_name}}*\\nAccount: {{$json.account_to_post_from}}\\n\\nüìù {{$json.confirmed_caption.caption}}\\n\\n{{$json.confirmed_caption.hashtags}}\\n\\nüîó {{$json.outputFile}}",
        "additionalFields": {}
      },
      "id": "slack-notify",
      "name": "25. Slack - Notify Ready",
      "type": "n8n-nodes-base.slack",
      "typeVersion": 3,
      "position": [6160, 300],
      "credentials": {
        "slackApi": {
          "id": "[REPLACE: Slack Bot Token]",
          "name": "Slack Bot Token"
        }
      }
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ JSON.stringify({ success: true, campaign: $json.campaign_name, clipId: $json.id, status: $json.approved ? 'READY_TO_POST' : 'NEEDS_REVISION' }) }}",
        "options": {}
      },
      "id": "respond-webhook",
      "name": "26. Respond to Webhook",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [6380, 300]
    },
    {
      "parameters": {},
      "id": "error-trigger",
      "name": "On Workflow Error",
      "type": "n8n-nodes-base.errorTrigger",
      "typeVersion": 1,
      "position": [2200, 700]
    },
    {
      "parameters": {
        "channel": "clip-pipeline-errors",
        "text": "‚ùå *Workflow Error*\\n\\nWorkflow: Content Rewards\\nFailed: {{ $json.execution?.lastNodeExecuted }}\\nError: {{ $json.execution?.error?.message }}\\nInput: {{ $json.execution?.input?.json?.campaign_name }}",
        "additionalFields": {}
      },
      "id": "error-alert",
      "name": "Alert - Error",
      "type": "n8n-nodes-base.slack",
      "typeVersion": 3,
      "position": [2420, 700],
      "credentials": {
        "slackApi": {
          "id": "[REPLACE: Slack Bot Token]",
          "name": "Slack Bot Token"
        }
      }
    }
  ],
  "connections": {
    "1. Webhook Trigger": {
      "main": [[{ "node": "2. Parse Webhook Input", "type": "main", "index": 0 }]]
    },
    "2. Parse Webhook Input": {
      "main": [[{ "node": "3. Lookup Campaign Config", "type": "main", "index": 0 }]]
    },
    "3. Lookup Campaign Config": {
      "main": [[{ "node": "4. Build Campaign Config", "type": "main", "index": 0 }]]
    },
    "4. Build Campaign Config": {
      "main": [[{ "node": "5. Download YouTube Video", "type": "main", "index": 0 }]]
    },
    "5. Download YouTube Video": {
      "main": [[{ "node": "6. Build Prompt 1", "type": "main", "index": 0 }]]
    },
    "6. Build Prompt 1": {
      "main": [[{ "node": "7. Claude - Identify Viral Clips", "type": "main", "index": 0 }]]
    },
    "7. Claude - Identify Viral Clips": {
      "main": [[{ "node": "8. Parse Viral Clips", "type": "main", "index": 0 }]]
    },
    "8. Parse Viral Clips": {
      "main": [[{ "node": "9. Slack - Select Clips", "type": "main", "index": 0 }]]
    },
    "9. Slack - Select Clips": {
      "main": [[{ "node": "9. Wait for Clip Selection", "type": "main", "index": 0 }]]
    },
    "9. Wait for Clip Selection": {
      "main": [[{ "node": "10. Parse Clip Selection", "type": "main", "index": 0 }]]
    },
    "10. Parse Clip Selection": {
      "main": [[{ "node": "11. Loop Over Clips", "type": "main", "index": 0 }]]
    },
    "11. Loop Over Clips": {
      "main": [
        [{ "node": "12. Build Prompt 2", "type": "main", "index": 0 }],
        [{ "node": "26. Respond to Webhook", "type": "main", "index": 0 }]
      ]
    },
    "12. Build Prompt 2": {
      "main": [[{ "node": "13. Claude - Generate Captions", "type": "main", "index": 0 }]]
    },
    "13. Claude - Generate Captions": {
      "main": [[{ "node": "14. Parse Captions", "type": "main", "index": 0 }]]
    },
    "14. Parse Captions": {
      "main": [[{ "node": "15. Slack - Select Caption", "type": "main", "index": 0 }]]
    },
    "15. Slack - Select Caption": {
      "main": [[{ "node": "15. Wait for Caption", "type": "main", "index": 0 }]]
    },
    "15. Wait for Caption": {
      "main": [[{ "node": "16. Parse Caption Selection", "type": "main", "index": 0 }]]
    },
    "16. Parse Caption Selection": {
      "main": [
        [{ "node": "17a. Trim Hook Clip", "type": "main", "index": 0 }],
        [{ "node": "17b. Trim Main Clip", "type": "main", "index": 0 }]
      ]
    },
    "17a. Trim Hook Clip": {
      "main": [[{ "node": "19. Build Render Props", "type": "main", "index": 0 }]]
    },
    "17b. Trim Main Clip": {
      "main": [
        [{ "node": "18. Transcribe Main Clip", "type": "main", "index": 0 }],
        [{ "node": "19. Build Render Props", "type": "main", "index": 0 }]
      ]
    },
    "18. Transcribe Main Clip": {
      "main": [[{ "node": "19. Build Render Props", "type": "main", "index": 0 }]]
    },
    "19. Build Render Props": {
      "main": [[{ "node": "20. Start Lambda Render", "type": "main", "index": 0 }]]
    },
    "20. Start Lambda Render": {
      "main": [[{ "node": "20. Wait for Render", "type": "main", "index": 0 }]]
    },
    "20. Wait for Render": {
      "main": [[{ "node": "21. Parse Render Result", "type": "main", "index": 0 }]]
    },
    "21. Parse Render Result": {
      "main": [[{ "node": "22. Slack - Final Review", "type": "main", "index": 0 }]]
    },
    "22. Slack - Final Review": {
      "main": [[{ "node": "22. Wait for Final", "type": "main", "index": 0 }]]
    },
    "22. Wait for Final": {
      "main": [[{ "node": "23. Parse Final Decision", "type": "main", "index": 0 }]]
    },
    "23. Parse Final Decision": {
      "main": [[{ "node": "24. Airtable - Create Record", "type": "main", "index": 0 }]]
    },
    "24. Airtable - Create Record": {
      "main": [[{ "node": "25. Slack - Notify Ready", "type": "main", "index": 0 }]]
    },
    "25. Slack - Notify Ready": {
      "main": [[{ "node": "26. Respond to Webhook", "type": "main", "index": 0 }]]
    },
    "On Workflow Error": {
      "main": [[{ "node": "Alert - Error", "type": "main", "index": 0 }]]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1",
    "saveManualExecutions": true,
    "callerPolicy": "workflowsFromSameOwner",
    "errorWorkflow": ""
  },
  "meta": {
    "instanceId": ""
  },
  "tags": ["content-rewards", "video-automation", "claude"]
}
